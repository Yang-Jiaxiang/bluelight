function decodeRLE(e,t){if(8===e.bitsAllocated)return e.planarConfiguration?decode8Planar(e,t):decode8(e,t);if(16===e.bitsAllocated)return decode16(e,t);throw new Error("unsupported pixel format for RLE")}function decode8(e,t){const r=t,n=e.rows*e.columns,f=new ArrayBuffer(n*e.samplesPerPixel),o=new DataView(r.buffer,r.byteOffset),l=new Int8Array(r.buffer,r.byteOffset),a=new Int8Array(f);let s=0;const i=o.getInt32(0,!0);for(let t=0;t<i;++t){s=t;let f=o.getInt32(4*(t+1),!0),c=o.getInt32(4*(t+2),!0);0===c&&(c=r.length);const u=n*i;for(;f<c;){const t=l[f++];if(t>=0&&t<=127)for(let r=0;r<t+1&&s<u;++r)a[s]=l[f++],s+=e.samplesPerPixel;else if(t<=-1&&t>=-127){const r=l[f++];for(let n=0;n<1-t&&s<u;++n)a[s]=r,s+=e.samplesPerPixel}}}return e.pixelData=new Uint8Array(f),e}function decode8Planar(e,t){const r=t,n=e.rows*e.columns,f=new ArrayBuffer(n*e.samplesPerPixel),o=new DataView(r.buffer,r.byteOffset),l=new Int8Array(r.buffer,r.byteOffset),a=new Int8Array(f);let s=0;const i=o.getInt32(0,!0);for(let e=0;e<i;++e){s=e*n;let t=o.getInt32(4*(e+1),!0),f=o.getInt32(4*(e+2),!0);0===f&&(f=r.length);const c=n*i;for(;t<f;){const e=l[t++];if(e>=0&&e<=127)for(let r=0;r<e+1&&s<c;++r)a[s]=l[t++],s++;else if(e<=-1&&e>=-127){const r=l[t++];for(let t=0;t<1-e&&s<c;++t)a[s]=r,s++}}}return e.pixelData=new Uint8Array(f),e}function decode16(e,t){const r=t,n=e.rows*e.columns,f=new ArrayBuffer(n*e.samplesPerPixel*2),o=new DataView(r.buffer,r.byteOffset),l=new Int8Array(r.buffer,r.byteOffset),a=new Int8Array(f),s=o.getInt32(0,!0);for(let e=0;e<s;++e){let t=0;const f=0===e?1:0;let s=o.getInt32(4*(e+1),!0),i=o.getInt32(4*(e+2),!0);for(0===i&&(i=r.length);s<i;){const e=l[s++];if(e>=0&&e<=127)for(let r=0;r<e+1&&t<n;++r)a[2*t+f]=l[s++],t++;else if(e<=-1&&e>=-127){const r=l[s++];for(let o=0;o<1-e&&t<n;++o)a[2*t+f]=r,t++}}}return 0===e.pixelRepresentation?e.pixelData=new Uint16Array(f):e.pixelData=new Int16Array(f),e}export default decodeRLE;